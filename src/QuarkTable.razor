@using System.Threading
@using Microsoft.Extensions.Logging
@using Soenneker.DataTables.Dtos.ServerSideRequest
@using Soenneker.Extensions.Task
@using Soenneker.Extensions.ValueTask
@using Soenneker.Quark.Table.Options
@using Soenneker.Quark.Table.Abstract
@using Soenneker.Utils.Debounce
@using Soenneker.Quark.Table

@inherits ComponentBase
@implements IQuarkTable

<CascadingValue Value="this" IsFixed="true">
    <div class="quark-table-wrapper" style="@(Visible ? string.Empty : "visibility:hidden;position:absolute;left:-9999px")" >

        <div class="quark-table-container" >
            @if (!_isLoading && ChildContent == null)
            {
                <div class="text-center p-4" >
                    <p>No content available</p>
                </div>
            }
            else
            {
                <div class="quark-table-with-search">
                    @if (ChildContent != null)
                    {
                        @ChildContent
                    }
                </div>
            }
        </div>

    </div>
</CascadingValue>

@code {

    [Inject]
    private IQuarkTableInterop QuarkTableInterop { get; set; } = null!;

    [Inject]
    private ILogger<QuarkTable> Logger { get; set; } = null!;

    [Parameter]
    public EventCallback OnInitialize { get; set; }

    [Parameter]
    public EventCallback<int> OnPageSizeChanged { get; set; }

    [Parameter]
    public EventCallback<int> OnGoToPage { get; set; }

    [Parameter]
    public EventCallback<QuarkTableOrderEventArgs> OnOrder { get; set; }

    [Parameter]
    public QuarkTableOptions Options { get; set; } = new();

    [Parameter]
    public RenderFragment? LoadingIndicator { get; set; }

    [Parameter]
    public bool Visible { get; set; } = true;

    [Parameter]
    public bool ShowPageSizeSelector { get; set; } = true;

    [Parameter]
    public int[] PageSizeOptions { get; set; } = [10, 25, 50, 100];

    [Parameter]
    public int MaxPageButtons { get; set; } = 5;

    [Parameter]
    public bool EnableManualHeaderSorting { get; set; }

    [Parameter]
    public int TotalRecords { get; set; }

    [Parameter]
    public EventCallback<DataTableServerSideRequest> OnManualRequest { get; set; }

    [Parameter]
    public RenderFragment? ChildContent { get; set; }

    public readonly string ElementId = $"quark-table-{Guid.NewGuid():N}";

    // Debug properties
    public int CurrentPage => _currentPage;
    public int PageSize => _pageSize;
    public int TotalPages => _totalPages;

    // Interface implementation
    QuarkTableOptions IQuarkTable.Options => _options;

    private readonly Debouncer _debouncer = new();
    private readonly List<DataTableOrderRequest> _currentOrders = [];

    private string _searchTerm = string.Empty;
    private string? _continuationToken;

    private int _currentPage = 1;
    private int _pageSize;
    private int _totalRecords;
    private int _totalPages;

    private bool _dataChanged;
    private bool _isLoading;
    private bool _initialized;
    private bool _dataLoaded;
    private QuarkTableOptions? _previousOptions;
    private QuarkTableOptions _options = new();

    public int TotalRecordsCount => _totalRecords;

    private int StartRecord => (_currentPage - 1) * _pageSize + 1;
    private int EndRecord => Math.Min(_currentPage * _pageSize, _totalRecords);
    public int StartPage
    {
        get
        {
            // Ensure we have valid values
            if (_totalPages <= 0) return 1;
            if (_currentPage <= 0) return 1;

            // Simple pagination: show a window around the current page
            int halfButtons = Options.MaxPageButtons / 2;
            int start = _currentPage - halfButtons;

            // Ensure we don't go below page 1
            start = Math.Max(1, start);

            // If we's near the end, adjust to show the last MaxPageButtons pages
            if (start + Options.MaxPageButtons - 1 > _totalPages)
            {
                start = Math.Max(1, _totalPages - Options.MaxPageButtons + 1);
            }

            // Ensure we don't exceed total pages
            if (start > _totalPages) start = _totalPages;

            return start;
        }
    }

    public int EndPage => Math.Min(_totalPages, StartPage + Options.MaxPageButtons - 1);

    protected override async Task OnInitializedAsync()
    {
        _pageSize = Options.DefaultPageSize;
        await QuarkTableInterop.Initialize();

        _initialized = true;
        if (OnInitialize.HasDelegate)
            await OnInitialize.InvokeAsync();
    }

    protected override async Task OnParametersSetAsync()
    {
        // Update the backing field for Options
        _options = Options;

        // Initialize total records and pages on first parameter set
        if (!_dataLoaded)
        {
            _totalRecords = TotalRecords;
            _totalPages = (int) Math.Ceiling((double) _totalRecords / _pageSize);
            
            // Load initial data
            if (OnManualRequest.HasDelegate)
            {
                await HandleManualRequest();
            }
            _dataLoaded = true;
        }
        else
        {
            // Check if TotalRecords has changed
            if (_totalRecords != TotalRecords)
            {
                _totalRecords = TotalRecords;
                _totalPages = (int) Math.Ceiling((double) _totalRecords / _pageSize);
                Logger.LogDebug("TotalRecords updated to {TotalRecords}, TotalPages={TotalPages}", _totalRecords, _totalPages);
            }
        }

        // Check if options have changed and trigger reload if needed
        if (_initialized && _previousOptions != null && !Options.Equals(_previousOptions))
        {
            _pageSize = Options.DefaultPageSize;
            _currentPage = 1;
            // Clear continuation token when options change
            _continuationToken = null;
            if (OnManualRequest.HasDelegate)
            {
                await HandleManualRequest();
            }
        }

        _previousOptions = Options.Clone();
        await base.OnParametersSetAsync();
    }



    private async Task OnPageSizeChangedHandler(ChangeEventArgs e)
    {
        if (int.TryParse(e.Value?.ToString(), out int size) && size != _pageSize)
        {
            _pageSize = size;
            _currentPage = 1;
            // Clear continuation token when changing page size
            _continuationToken = null;
            await HandleManualRequest();
            if (OnPageSizeChanged.HasDelegate) await OnPageSizeChanged.InvokeAsync(_pageSize);
        }
    }



    public async Task HandleGoToPage(int page)
    {
        if (page < 1 || page > _totalPages) return;

        _currentPage = page;
        // Clear continuation token when changing pages
        _continuationToken = null;
        await HandleManualRequest();

        if (OnGoToPage.HasDelegate)
            await OnGoToPage.InvokeAsync(page);
    }

    public async Task HandleSearch(string searchTerm)
    {
        Logger.LogDebug("HandleSearch called with term: {SearchTerm}", searchTerm);
        
        _searchTerm = searchTerm;
        _currentPage = 1; // Reset to first page when searching
        _continuationToken = null; // Clear continuation token when searching
        
        await HandleManualRequest();
    }

    public async Task HandleSort(int columnIndex)
    {
        if (!Options.Sortable) return;

        Logger.LogDebug("Sorting column by index: {ColumnIndex}", columnIndex);

        // Find existing order for this column
        DataTableOrderRequest? existing = _currentOrders.FirstOrDefault(o => o.Column == columnIndex);
        string? nextDirection = existing?.Dir switch
        {
            "asc" => "desc",
            "desc" => null,
            _ => "asc"
        };

        // Remove existing order for this column
        _currentOrders.RemoveAll(o => o.Column == columnIndex);
        
        // Add new order if direction is not null
        if (nextDirection != null)
        {
            _currentOrders.Add(new DataTableOrderRequest 
            { 
                Column = columnIndex, 
                Dir = nextDirection 
            });
            Logger.LogDebug("Added order: Column={Column}, Direction={Direction}", columnIndex, nextDirection);
        }
        else
        {
            Logger.LogDebug("Removed order for column {Column}", columnIndex);
        }
        
        Logger.LogDebug("Current orders count: {Count}", _currentOrders.Count);

        _currentPage = 1;
        // Clear continuation token when sorting
        _continuationToken = null;
        await HandleManualRequest();

        if (OnOrder.HasDelegate)
        {
            var args = new QuarkTableOrderEventArgs 
            {
                Column = $"Column_{columnIndex}", 
                Direction = nextDirection ?? string.Empty, 
                Orders = _currentOrders.ToList()
            };
            await OnOrder.InvokeAsync(args);
        }
    }

    /// <summary>
    /// Gets the current orders
    /// </summary>
    /// <returns>A copy of the current orders</returns>
    public List<DataTableOrderRequest> GetCurrentOrders()
    {
        return _currentOrders.ToList();
    }

    /// <summary>
    /// Sets the orders programmatically and triggers a reload
    /// </summary>
    /// <param name="orders">The orders to set</param>
    public async Task SetOrders(List<DataTableOrderRequest> orders)
    {
        _currentOrders.Clear();
        if (orders != null)
        {
            _currentOrders.AddRange(orders);
        }
        _currentPage = 1;
        _continuationToken = null;
        await HandleManualRequest();
    }

    /// <summary>
    /// Sorts a column by index (for use in manual mode)
    /// </summary>
    /// <param name="columnIndex">The column index to sort</param>
    public async Task SortColumnByIndex(int columnIndex)
    {
        if (!Options.Sortable) return;

        Logger.LogDebug("Sorting column by index: {ColumnIndex}", columnIndex);

        // Find existing order for this column
        DataTableOrderRequest? existing = _currentOrders.FirstOrDefault(o => o.Column == columnIndex);
        string? nextDirection = existing?.Dir switch
        {
            "asc" => "desc",
            "desc" => null,
            _ => "asc"
        };

        // Remove existing order for this column
        _currentOrders.RemoveAll(o => o.Column == columnIndex);
        
        // Add new order if direction is not null
        if (nextDirection != null)
        {
            _currentOrders.Add(new DataTableOrderRequest 
            { 
                Column = columnIndex, 
                Dir = nextDirection 
            });
            Logger.LogDebug("Added order: Column={Column}, Direction={Direction}", columnIndex, nextDirection);
        }
        else
        {
            Logger.LogDebug("Removed order for column {Column}", columnIndex);
        }
        
        Logger.LogDebug("Current orders count: {Count}", _currentOrders.Count);

        _currentPage = 1;
        // Clear continuation token when sorting
        _continuationToken = null;
        await HandleManualRequest();

        if (OnOrder.HasDelegate)
        {
            var args = new QuarkTableOrderEventArgs 
            {
                Column = $"Column_{columnIndex}", 
                Direction = nextDirection ?? string.Empty, 
                Orders = _currentOrders.ToList()
            };
            await OnOrder.InvokeAsync(args);
        }
    }

    /// <summary>
    /// Gets the current sort direction for a column index
    /// </summary>
    /// <param name="columnIndex">The column index</param>
    /// <returns>The sort direction ("asc", "desc", or null if not sorted)</returns>
    public string? GetSortDirection(int columnIndex)
    {
        DataTableOrderRequest? order = _currentOrders.FirstOrDefault(o => o.Column == columnIndex);
        return order?.Dir;
    }

    /// <summary>
    /// Gets the CSS class for a column index based on its sort state
    /// </summary>
    /// <param name="columnIndex">The column index</param>
    /// <returns>The CSS class for the sort state</returns>
    public string GetSortClassByIndex(int columnIndex)
    {
        string? direction = GetSortDirection(columnIndex);
        return direction switch 
        {
            "asc" => "quark-table-sorted-asc", 
            "desc" => "quark-table-sorted-desc", 
            _ => string.Empty
        };
    }

    /// <summary>
    /// Gets the sort indicator for a column index
    /// </summary>
    /// <param name="columnIndex">The column index</param>
    /// <returns>The sort indicator (↑, ↓, or ↕)</returns>
    public string GetSortIndicatorByIndex(int columnIndex)
    {
        string? direction = GetSortDirection(columnIndex);
        return direction switch 
        {
            "asc" => " ↑", 
            "desc" => " ↓", 
            _ => " ↕"
        };
    }



    private async Task HandleFirstPage()
    {
        if (_currentPage == 1) return;
        _currentPage = 1;
        // Clear continuation token when going to first page
        _continuationToken = null;
        await HandleManualRequest();
    }

    private async Task HandlePreviousPage()
    {
        if (_currentPage == 1) return;
        _currentPage--;
        // Clear continuation token when navigating backwards
        _continuationToken = null;
        await HandleManualRequest();
    }

    private async Task HandleNextPage()
    {
        if (_currentPage == _totalPages) return;
        _currentPage++;
        await HandleManualRequest();
    }

    private async Task HandleLastPage()
    {
        if (_currentPage == _totalPages) return;
        _currentPage = _totalPages;
        await HandleManualRequest();
    }

    public async Task HandleColumnSort(int columnIndex, string columnName)
    {
        if (!Options.Sortable) return;

        Logger.LogDebug("HandleColumnSort called: columnIndex={ColumnIndex}, columnName={ColumnName}", columnIndex, columnName);

        // Find existing order for this column
        DataTableOrderRequest? existing = _currentOrders.FirstOrDefault(o => o.Column == columnIndex);
        string? nextDirection = existing?.Dir switch
        {
            "asc" => "desc",
            "desc" => null,
            _ => "asc"
        };

        // Remove existing order for this column
        _currentOrders.RemoveAll(o => o.Column == columnIndex);
        
        // Add new order if direction is not null
        if (nextDirection != null)
        {
            _currentOrders.Add(new DataTableOrderRequest 
            { 
                Column = columnIndex, 
                Dir = nextDirection 
            });
        }

        // Reset to page 1 when sorting
        _currentPage = 1;
        // Clear continuation token when sorting
        _continuationToken = null;
        await HandleManualRequest();

        if (OnOrder.HasDelegate)
        {
            var args = new QuarkTableOrderEventArgs 
            {
                Column = columnName, 
                Direction = nextDirection ?? string.Empty, 
                Orders = _currentOrders.ToList()
            };
            await OnOrder.InvokeAsync(args);
        }
    }

    private async Task HandleManualRequest(CancellationToken cancellationToken = default)
    {
        Logger.LogDebug("HandleManualRequest called: Page={Page}, PageSize={PageSize}, SearchTerm='{SearchTerm}'", 
            _currentPage, _pageSize, _searchTerm);
            
        if (!OnManualRequest.HasDelegate) 
        {
            Logger.LogWarning("HandleManualRequest: No OnManualRequest delegate");
            return;
        }

        _isLoading = true;
        _dataChanged = true;
        await InvokeAsync(StateHasChanged).NoSync();

        try
        {
            var request = new DataTableServerSideRequest
            {
                Start = (_currentPage - 1) * _pageSize,
                Length = _pageSize,
                Search = !string.IsNullOrEmpty(_searchTerm) ? new DataTableSearchRequest { Value = _searchTerm } : null,
                Order = _currentOrders.Count > 0 ? _currentOrders : null,
                ContinuationToken = _continuationToken
            };
            
            Logger.LogDebug("Sending request: Start={Start}, Length={Length}, Search='{Search}'", 
                request.Start, request.Length, request.Search?.Value ?? "null");
                
            await OnManualRequest.InvokeAsync(request);
            _dataChanged = true;
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "HandleManualRequest error: {Message}", ex.Message);
        }
        finally
        {
            _isLoading = false;
            _dataChanged = true;
            await InvokeAsync(StateHasChanged).NoSync();
        }
    }

    protected override bool ShouldRender()
    {
        bool s = _dataChanged;
        _dataChanged = false;
        return s;
    }

    public async ValueTask DisposeAsync()
    {
        await _debouncer.DisposeAsync();
    }

    /// <summary>
    /// Clears all current sorting and resets to first page
    /// </summary>
    public async Task ClearSorting()
    {
        _currentOrders.Clear();
        _currentPage = 1;
        _continuationToken = null;
        await HandleManualRequest();
    }

    /// <summary>
    /// Resets the table to its initial state (clears sorting and goes to first page)
    /// </summary>
    public async Task Reset()
    {
        _currentOrders.Clear();
        _currentPage = 1;
        _continuationToken = null;
        await HandleManualRequest();
    }

} 