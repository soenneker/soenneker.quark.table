@using System.Threading
@using Microsoft.Extensions.Logging
@using Soenneker.DataTables.Dtos.ServerSideRequest
@using Soenneker.Extensions.Task
@using Soenneker.Extensions.ValueTask
@using Soenneker.Quark.Table.Options
@using Soenneker.Quark.Table.Abstract
@using Soenneker.Utils.Debounce
@using Soenneker.Quark.Table

@inherits ComponentBase
@implements IQuarkTable

<CascadingValue Value="this" IsFixed="true">
    <div class="quark-table-wrapper" style="@(Visible ? string.Empty : "visibility:hidden;position:absolute;left:-9999px")" >

        <div class="quark-table-container" >
            @if (!_isLoading && ChildContent == null)
            {
                <div class="text-center p-4" >
                    <p>No content available</p>
                </div>
            }
            else
            {
                <div class="quark-table-with-search">
                    @if (ChildContent != null)
                    {
                        @ChildContent
                    }
                </div>
            }
        </div>

    </div>
</CascadingValue>

@code {

    [Inject]
    private IQuarkTableInterop QuarkTableInterop { get; set; } = null!;

    [Inject]
    private ILogger<QuarkTable> Logger { get; set; } = null!;

    [Parameter]
    public EventCallback OnInitialize { get; set; }

    [Parameter]
    public EventCallback<int> OnPageSizeChanged { get; set; }

    [Parameter]
    public EventCallback<int> OnGoToPage { get; set; }

    [Parameter]
    public EventCallback<QuarkTableOrderEventArgs> OnOrder { get; set; }

    [Parameter]
    public QuarkTableOptions Options { get; set; } = new();

    [Parameter]
    public RenderFragment? LoadingIndicator { get; set; }

    [Parameter]
    public bool Visible { get; set; } = true;

    [Parameter]
    public bool ShowPageSizeSelector { get; set; } = true;

    [Parameter]
    public int[] PageSizeOptions { get; set; } = [10, 25, 50, 100];

    [Parameter]
    public int MaxPageButtons { get; set; } = 5;

    [Parameter]
    public bool EnableManualHeaderSorting { get; set; }

    [Parameter]
    public int TotalRecords { get; set; }

    [Parameter]
    public EventCallback<DataTableServerSideRequest> OnManualRequest { get; set; }

    [Parameter]
    public RenderFragment? ChildContent { get; set; }

    public readonly string ElementId = $"quark-table-{Guid.NewGuid():N}";

    // Debug properties
    public int CurrentPage => _currentPage;
    public int PageSize => _pageSize;
    public int TotalPages => _totalPages;

    // Interface implementation
    QuarkTableOptions IQuarkTable.Options => _options;

    private readonly Debouncer _debouncer = new();
    private readonly List<DataTableOrderRequest> _currentOrders = [];
    private readonly QuarkTableContinuationTokenPaging _continuationTokenPaging = new();

    private string _searchTerm = string.Empty;
    private string? _continuationToken;

    private int _currentPage = 1;
    private int _pageSize;
    private int _totalRecords;
    private int _totalPages;

    private bool _dataChanged;
    private bool _isLoading;
    private bool _initialized;
    private bool _dataLoaded;
    private bool _isUpdatingParameters; // Flag to prevent infinite loops
    private bool _isHandlingManualRequest; // Flag to prevent multiple simultaneous manual requests
    private int _manualRequestCount = 0; // Counter to track manual request calls
    private QuarkTableOptions? _previousOptions;
    private QuarkTableOptions _options = new();

    public int TotalRecordsCount => _totalRecords;

    private int StartRecord => (_currentPage - 1) * _pageSize + 1;
    private int EndRecord => Math.Min(_currentPage * _pageSize, _totalRecords);
    public int StartPage
    {
        get
        {
            // Ensure we have valid values
            if (_totalPages <= 0) return 1;
            if (_currentPage <= 0) return 1;

            // Simple pagination: show a window around the current page
            int halfButtons = Options.MaxPageButtons / 2;
            int start = _currentPage - halfButtons;

            // Ensure we don't go below page 1
            start = Math.Max(1, start);

            // If we's near the end, adjust to show the last MaxPageButtons pages
            if (start + Options.MaxPageButtons - 1 > _totalPages)
            {
                start = Math.Max(1, _totalPages - Options.MaxPageButtons + 1);
            }

            // Ensure we don't exceed total pages
            if (start > _totalPages) start = _totalPages;

            return start;
        }
    }

    public int EndPage => Math.Min(_totalPages, StartPage + Options.MaxPageButtons - 1);

    protected override async Task OnInitializedAsync()
    {
        _pageSize = Options.DefaultPageSize;
        await QuarkTableInterop.Initialize();

        _initialized = true;
        if (OnInitialize.HasDelegate)
            await OnInitialize.InvokeAsync();
    }

    protected override async Task OnParametersSetAsync()
    {
        // Prevent infinite loops by checking if we're already updating parameters
        if (_isUpdatingParameters)
        {
            Logger.LogDebug("OnParametersSetAsync called while already updating parameters - skipping");
            return;
        }

        Logger.LogDebug("OnParametersSetAsync called: _dataLoaded={DataLoaded}, _initialized={Initialized}, TotalRecords={TotalRecords}, _totalRecords={CurrentTotalRecords}", 
            _dataLoaded, _initialized, TotalRecords, _totalRecords);
            
        _isUpdatingParameters = true;
        
        try
        {
            // Update the backing field for Options
            _options = Options;

            // Initialize total records and pages on first parameter set
            if (!_dataLoaded)
            {
                Logger.LogDebug("First parameter set - initializing data");
                _totalRecords = TotalRecords;
                _totalPages = (int) Math.Ceiling((double) _totalRecords / _pageSize);
                
                // Load initial data
                if (OnManualRequest.HasDelegate)
                {
                    Logger.LogDebug("Calling HandleManualRequest for initial data load");
                    await HandleManualRequest();
                }
                _dataLoaded = true;
            }
            else
            {
                // Check if TotalRecords has changed
                if (_totalRecords != TotalRecords)
                {
                    Logger.LogDebug("TotalRecords changed from {OldTotal} to {NewTotal}", _totalRecords, TotalRecords);
                    _totalRecords = TotalRecords;
                    _totalPages = (int) Math.Ceiling((double) _totalRecords / _pageSize);
                    Logger.LogDebug("TotalRecords updated to {TotalRecords}, TotalPages={TotalPages}", _totalRecords, _totalPages);
                }
            }

            // Check if options have changed and trigger reload if needed
            if (_initialized && _previousOptions != null && !Options.Equals(_previousOptions))
            {
                Logger.LogDebug("Options changed - resetting table");
                _pageSize = Options.DefaultPageSize;
                _currentPage = 1;
                // Clear continuation token when options change
                _continuationToken = null;
                _continuationTokenPaging.Reset();
                if (OnManualRequest.HasDelegate)
                {
                    await HandleManualRequest();
                }
            }

            _previousOptions = Options.Clone();
        }
        finally
        {
            _isUpdatingParameters = false;
        }
        
        await base.OnParametersSetAsync();
    }



    private async Task OnPageSizeChangedHandler(ChangeEventArgs e)
    {
        if (int.TryParse(e.Value?.ToString(), out int size) && size != _pageSize)
        {
            _pageSize = size;
            _currentPage = 1;
            // Clear continuation token when changing page size
            _continuationToken = null;
            await HandleManualRequest();
            if (OnPageSizeChanged.HasDelegate) await OnPageSizeChanged.InvokeAsync(_pageSize);
        }
    }



    public async Task HandleGoToPage(int page)
    {
        if (page < 1 || page > _totalPages) return;

        _currentPage = page;
        // Clear continuation token when changing pages
        _continuationToken = null;
        await HandleManualRequest();

        if (OnGoToPage.HasDelegate)
            await OnGoToPage.InvokeAsync(page);
    }

    public async Task HandleSearch(string searchTerm)
    {
        Logger.LogDebug("HandleSearch called with term: {SearchTerm}", searchTerm);
        
        _searchTerm = searchTerm;
        _currentPage = 1; // Reset to first page when searching
        _continuationTokenPaging.Reset(); // Reset continuation token paging when searching
        _continuationToken = null; // Clear continuation token when searching
        
        await HandleManualRequest();
    }

    public async Task HandleSort(int columnIndex)
    {
        if (!Options.Sortable) return;

        Logger.LogDebug("Sorting column by index: {ColumnIndex}", columnIndex);

        // Find existing order for this column
        DataTableOrderRequest? existing = _currentOrders.FirstOrDefault(o => o.Column == columnIndex);
        string? nextDirection = existing?.Dir switch
        {
            "asc" => "desc",
            "desc" => null,
            _ => "asc"
        };

        // Remove existing order for this column
        _currentOrders.RemoveAll(o => o.Column == columnIndex);
        
        // Add new order if direction is not null
        if (nextDirection != null)
        {
            _currentOrders.Add(new DataTableOrderRequest 
            { 
                Column = columnIndex, 
                Dir = nextDirection 
            });
            Logger.LogDebug("Added order: Column={Column}, Direction={Direction}", columnIndex, nextDirection);
        }
        else
        {
            Logger.LogDebug("Removed order for column {Column}", columnIndex);
        }
        
        Logger.LogDebug("Current orders count: {Count}", _currentOrders.Count);

        _currentPage = 1;
        // Reset continuation token paging when sorting
        _continuationTokenPaging.Reset();
        _continuationToken = null;
        await HandleManualRequest();

        if (OnOrder.HasDelegate)
        {
            var args = new QuarkTableOrderEventArgs 
            {
                Column = $"Column_{columnIndex}", 
                Direction = nextDirection ?? string.Empty, 
                Orders = _currentOrders.ToList()
            };
            await OnOrder.InvokeAsync(args);
        }
    }

    /// <summary>
    /// Gets the current orders
    /// </summary>
    /// <returns>A copy of the current orders</returns>
    public List<DataTableOrderRequest> GetCurrentOrders()
    {
        return _currentOrders.ToList();
    }

    /// <summary>
    /// Sets the orders programmatically and triggers a reload
    /// </summary>
    /// <param name="orders">The orders to set</param>
    public async Task SetOrders(List<DataTableOrderRequest> orders)
    {
        _currentOrders.Clear();
        if (orders != null)
        {
            _currentOrders.AddRange(orders);
        }
        _currentPage = 1;
        _continuationTokenPaging.Reset();
        _continuationToken = null;
        await HandleManualRequest();
    }

    /// <summary>
    /// Sorts a column by index (for use in manual mode)
    /// </summary>
    /// <param name="columnIndex">The column index to sort</param>
    public async Task SortColumnByIndex(int columnIndex)
    {
        if (!Options.Sortable) return;

        Logger.LogDebug("Sorting column by index: {ColumnIndex}", columnIndex);

        // Find existing order for this column
        DataTableOrderRequest? existing = _currentOrders.FirstOrDefault(o => o.Column == columnIndex);
        string? nextDirection = existing?.Dir switch
        {
            "asc" => "desc",
            "desc" => null,
            _ => "asc"
        };

        // Remove existing order for this column
        _currentOrders.RemoveAll(o => o.Column == columnIndex);
        
        // Add new order if direction is not null
        if (nextDirection != null)
        {
            _currentOrders.Add(new DataTableOrderRequest 
            { 
                Column = columnIndex, 
                Dir = nextDirection 
            });
            Logger.LogDebug("Added order: Column={Column}, Direction={Direction}", columnIndex, nextDirection);
        }
        else
        {
            Logger.LogDebug("Removed order for column {Column}", columnIndex);
        }
        
        Logger.LogDebug("Current orders count: {Count}", _currentOrders.Count);

        _currentPage = 1;
        // Reset continuation token paging when sorting
        _continuationTokenPaging.Reset();
        _continuationToken = null;
        await HandleManualRequest();

        if (OnOrder.HasDelegate)
        {
            var args = new QuarkTableOrderEventArgs 
            {
                Column = $"Column_{columnIndex}", 
                Direction = nextDirection ?? string.Empty, 
                Orders = _currentOrders.ToList()
            };
            await OnOrder.InvokeAsync(args);
        }
    }

    /// <summary>
    /// Gets the current sort direction for a column index
    /// </summary>
    /// <param name="columnIndex">The column index</param>
    /// <returns>The sort direction ("asc", "desc", or null if not sorted)</returns>
    public string? GetSortDirection(int columnIndex)
    {
        DataTableOrderRequest? order = _currentOrders.FirstOrDefault(o => o.Column == columnIndex);
        return order?.Dir;
    }

    /// <summary>
    /// Gets the CSS class for a column index based on its sort state
    /// </summary>
    /// <param name="columnIndex">The column index</param>
    /// <returns>The CSS class for the sort state</returns>
    public string GetSortClassByIndex(int columnIndex)
    {
        string? direction = GetSortDirection(columnIndex);
        return direction switch 
        {
            "asc" => "quark-table-sorted-asc", 
            "desc" => "quark-table-sorted-desc", 
            _ => string.Empty
        };
    }

    /// <summary>
    /// Gets the sort indicator for a column index
    /// </summary>
    /// <param name="columnIndex">The column index</param>
    /// <returns>The sort indicator (↑, ↓, or ↕)</returns>
    public string GetSortIndicatorByIndex(int columnIndex)
    {
        string? direction = GetSortDirection(columnIndex);
        return direction switch 
        {
            "asc" => " ↑", 
            "desc" => " ↓", 
            _ => " ↕"
        };
    }



    private async Task HandleFirstPage()
    {
        if (_currentPage == 1) return;
        _currentPage = 1;
        // Reset continuation token paging when going to first page
        _continuationTokenPaging.Reset();
        _continuationToken = null;
        await HandleManualRequest();
    }

    private async Task HandlePreviousPage()
    {
        if (_currentPage == 1) return;
        _currentPage--;
        // Let the continuation token paging handle backward navigation
        await HandleManualRequest();
    }

    private async Task HandleNextPage()
    {
        if (_currentPage == _totalPages) return;
        _currentPage++;
        // Don't clear continuation token for next page - let the paging system handle it
        await HandleManualRequest();
    }

    private async Task HandleLastPage()
    {
        if (_currentPage == _totalPages) return;
        _currentPage = _totalPages;
        await HandleManualRequest();
    }

    public async Task HandleColumnSort(int columnIndex, string columnName)
    {
        if (!Options.Sortable) return;

        Logger.LogDebug("HandleColumnSort called: columnIndex={ColumnIndex}, columnName={ColumnName}", columnIndex, columnName);

        // Find existing order for this column
        DataTableOrderRequest? existing = _currentOrders.FirstOrDefault(o => o.Column == columnIndex);
        string? nextDirection = existing?.Dir switch
        {
            "asc" => "desc",
            "desc" => null,
            _ => "asc"
        };

        // Remove existing order for this column
        _currentOrders.RemoveAll(o => o.Column == columnIndex);
        
        // Add new order if direction is not null
        if (nextDirection != null)
        {
            _currentOrders.Add(new DataTableOrderRequest 
            { 
                Column = columnIndex, 
                Dir = nextDirection 
            });
        }

        // Reset to page 1 when sorting
        _currentPage = 1;
        // Reset continuation token paging when sorting
        _continuationTokenPaging.Reset();
        _continuationToken = null;
        await HandleManualRequest();

        if (OnOrder.HasDelegate)
        {
            var args = new QuarkTableOrderEventArgs 
            {
                Column = columnName, 
                Direction = nextDirection ?? string.Empty, 
                Orders = _currentOrders.ToList()
            };
            await OnOrder.InvokeAsync(args);
        }
    }

    private async Task HandleManualRequest(CancellationToken cancellationToken = default)
    {
        // Prevent multiple simultaneous calls to HandleManualRequest
        if (_isHandlingManualRequest)
        {
            Logger.LogDebug("HandleManualRequest called while already handling a request - skipping");
            return;
        }

        // Prevent infinite loops by limiting consecutive calls
        if (_manualRequestCount > 100)
        {
            Logger.LogWarning("HandleManualRequest called too many times ({Count}) - possible infinite loop detected", _manualRequestCount);
            return;
        }

        _manualRequestCount++;
        Logger.LogDebug("HandleManualRequest called (count: {Count}): Page={Page}, PageSize={PageSize}, SearchTerm='{SearchTerm}'", 
            _manualRequestCount, _currentPage, _pageSize, _searchTerm);
            
        if (!OnManualRequest.HasDelegate) 
        {
            Logger.LogWarning("HandleManualRequest: No OnManualRequest delegate");
            return;
        }

        _isHandlingManualRequest = true;
        _isLoading = true;
        _dataChanged = true;
        await InvokeAsync(StateHasChanged).NoSync();

        try
        {
            // Calculate the actual start position based on current page
            int actualStart = (_currentPage - 1) * _pageSize;
            
            // Use continuation token paging to get the appropriate token
            string? continuationToken = _continuationTokenPaging.UpdateVirtualPage(actualStart, _pageSize, _continuationToken);

            var request = new DataTableServerSideRequest
            {
                Start = actualStart,
                Length = _pageSize,
                Search = !string.IsNullOrEmpty(_searchTerm) ? new DataTableSearchRequest { Value = _searchTerm } : null,
                Order = _currentOrders.Count > 0 ? _currentOrders : null,
                ContinuationToken = continuationToken
            };
            
            Logger.LogDebug("Sending request: Start={Start}, Length={Length}, Search='{Search}', ContinuationToken='{Token}'", 
                request.Start, request.Length, request.Search?.Value ?? "null", request.ContinuationToken ?? "null");
                
            await OnManualRequest.InvokeAsync(request);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "HandleManualRequest error: {Message}", ex.Message);
        }
        finally
        {
            _isLoading = false;
            _dataChanged = true;
            _isHandlingManualRequest = false;
            await InvokeAsync(StateHasChanged).NoSync();
        }
    }

    protected override bool ShouldRender()
    {
        bool shouldRender = _dataChanged;
        if (shouldRender)
        {
            Logger.LogDebug("ShouldRender returning true - _dataChanged was true");
        }
        _dataChanged = false;
        return shouldRender;
    }

    public async ValueTask DisposeAsync()
    {
        await _debouncer.DisposeAsync();
    }

    /// <summary>
    /// Clears all current sorting and resets to first page
    /// </summary>
    public async Task ClearSorting()
    {
        _currentOrders.Clear();
        _currentPage = 1;
        _continuationTokenPaging.Reset();
        _continuationToken = null;
        _manualRequestCount = 0; // Reset the counter
        await HandleManualRequest();
    }

    /// <summary>
    /// Resets the table to its initial state (clears sorting and goes to first page)
    /// </summary>
    public async Task Reset()
    {
        _currentOrders.Clear();
        _currentPage = 1;
        _continuationToken = null;
        _continuationTokenPaging.Reset();
        _manualRequestCount = 0; // Reset the counter
        await HandleManualRequest();
    }

    /// <summary>
    /// Resets the manual request counter (useful for debugging)
    /// </summary>
    public void ResetManualRequestCounter()
    {
        _manualRequestCount = 0;
        Logger.LogDebug("Manual request counter reset to 0");
    }

    /// <summary>
    /// Updates the continuation token paging with response data
    /// </summary>
    /// <param name="recordCount">The number of records in the current response</param>
    /// <param name="continuationToken">The continuation token from the response</param>
    /// <param name="tokenUsedForCurrentPage">The continuation token that was used to reach the current page</param>
    public void UpdateContinuationTokenPaging(int recordCount, string? continuationToken, string? tokenUsedForCurrentPage = null)
    {
        Logger.LogDebug("UpdateContinuationTokenPaging called: RecordCount={RecordCount}, Token='{Token}', TokenUsed='{TokenUsed}', TotalRecords={TotalRecords}", 
            recordCount, continuationToken ?? "null", tokenUsedForCurrentPage ?? "null", TotalRecords);
            
        _continuationTokenPaging.UpdateFromResponse(_pageSize, recordCount, continuationToken, tokenUsedForCurrentPage);
        _continuationToken = continuationToken;
        
        // Only update total records estimate if TotalRecords parameter is not provided (0 or negative)
        // This prevents conflicts between the continuation token paging system and the provided TotalRecords
        if (TotalRecords <= 0)
        {
            int oldTotalRecords = _totalRecords;
            _totalRecords = _continuationTokenPaging.CalculateTotalRecords(_pageSize);
            Logger.LogDebug("Updated _totalRecords from {OldTotal} to {NewTotal} (TotalRecords parameter is {ParamTotal})", 
                oldTotalRecords, _totalRecords, TotalRecords);
        }
        else
        {
            Logger.LogDebug("Keeping _totalRecords as {CurrentTotal} (TotalRecords parameter is {ParamTotal})", 
                _totalRecords, TotalRecords);
        }
        
        int oldTotalPages = _totalPages;
        _totalPages = (int)Math.Ceiling((double)_totalRecords / _pageSize);
        
        Logger.LogDebug("Updated continuation token paging: RecordCount={RecordCount}, Token='{Token}', TotalRecords={TotalRecords}, TotalPages={TotalPages} (was {OldTotalPages})", 
            recordCount, continuationToken ?? "null", _totalRecords, _totalPages, oldTotalPages);
    }

} 